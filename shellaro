#!/usr/bin/env bash

###########################################################
#                                                         #
#           shellaro - a terminal music player            #
#         https://github.com/thomasjlsn/shellaro          #
#                                                         #
#                    inspired by fff                      #
#           https://github.com/dylanaraps/fff             #
#                                                         #
###########################################################

VERSION="1.5.0"

# CONFIG
# TODO external config file

# The directory Shellaro looks in for music
export MUSIC_DIRECTORY=~/Music

# Shortcuts corresponding to number keys
export SHORTCUT_1=~/Music/LedZeppelin
export SHORTCUT_2=~/Music/MotleyCrue
export SHORTCUT_3=~/Music/SlightlyStoopid
export SHORTCUT_4=~/Music/Sublime
export SHORTCUT_5=~/Music/TheDoors
export SHORTCUT_6=~/Music/TheRollingStones
export SHORTCUT_7=~/Music/TheWho
export SHORTCUT_8=~/Music/VanHalen
export SHORTCUT_9=~/Music/OTHER

# Status line
export COLOR_PLAYING=42 # Green
export COLOR_PAUSED=47 # White
export COLOR_STOPPED=47
export COLOR_MUTED=41 # Red

# Cursor color
export COLOR_CURSOR=37

# Directories
export COLOR_DIR=34 # Blue
export COLOR_DIR_BOLD=1 # Bold

# Color of currently playing song
export COLOR_CURRENT_SONG=32 # Green
export COLOR_CURRENT_SONG_BOLD=1

# Other
export COLOR_OTHER=37
export COLOR_OTHER_BOLD=0

# Marked files
export COLOR_MARKED=33 # Yellow
export COLOR_MARKED_BOLD=1
export ICON_MARKED="›"

# Status line icons
export ICON_PLAYING="▷"
export ICON_PAUSED="◫"
export ICON_STOPPED="□"
export ICON_MUTED="MUTE"

# Percent to raise or lower volume
export INCREMENT_VOLUME=5

# Cache directory
export XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}

export ERROR_LOG_FILE="${XDG_CACHE_HOME}/shellaro/error_log"
error() { echo "[ERROR]   $*" | tee -a "${ERROR_LOG_FILE}" >&2 ; }
fatal() { echo "[FATAL]   $*" | tee -a "${ERROR_LOG_FILE}" >&2 ; exit 1 ; }

setup_tui() {
    # '\e[?1049h': Use alternative screen buffer.
    # '\e[?7l':    Disable line wrapping.
    # '\e[?25l':   Hide the cursor.
    # '\e[2J':     Clear the screen.
    # '\e[1;Nr':   Limit scrolling to scrolling area.
    #              Also sets cursor to (0,0).
    printf '\e[?1049h\e[?7l\e[?25l\e[2J\e[1;%sr' "$max_items"

    # Hide input
    stty -echo
}

cleanup() {
    # '\e[?7h':   Re-enable line wrapping.
    # '\e[?25h':  Unhide the cursor.
    # '\e[2J':    Clear the terminal.
    # '\e[;r':    Set the scroll region to its default value.
    #             Also sets cursor to (0,0).
    # '\e[?1049l: Restore main screen buffer.
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'

    [[ "${DEBUG}" == true ]] && {
        set +x
        DEBUG=false
    }
    set +o nolog
    set +o pipefail

    echo "" > "${XDG_CACHE_HOME}/shellaro/playlist"

    set +h

    # Show input
    stty echo

    kill -SIGTERM "$(awk 'NR==1{print}' "${XDG_CACHE_HOME}"/shellaro/daemon_pid)"

#    clear
    exit 0
}

clear_screen() {
    # '\e[%sH':    Move cursor to bottom of scroll area.
    # '\e[9999C':  Move cursor to right edge of the terminal.
    # '\e[1J':     Clear screen to top left corner (from cursor up).
    # '\e[2J':     Clear screen fully (if using tmux) (fixes clear issues).
    # '\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.
    #              Also sets cursor to (0,0).
    printf '\e[%sH\e[9999C\e[1J%b\e[1;%sr' \
           "$((LINES-2))" "${TMUX:+\e[2J}" "$max_items"
}

get_term_size() {
    read -r LINES COLUMNS < <(stty size)

    # Max list items that fit in the scroll area
    # Leave 2 lines at the bottom for status & cmd line
    ((max_items=LINES-2))
}

set_initial_status() {
    local mpg321_pid=

    mpg321_pid="$(pgrep mpg321)"

    [ -n "${mpg321_pid}" ] && {
        if [[ $(awk 'NR==3{print $2}' "/proc/${mpg321_pid}/status") == "S" ]]; then
            IS_PAUSED=false
        elif [[ $(awk 'NR==3{print $2}' "/proc/${mpg321_pid}/status") == "T" ]]; then
            IS_PAUSED=true
        fi

        [ -n "$(amixer -D pulse get Master | awk '/\[off\]/')" ] && {
            IS_MUTED=true
        } || IS_MUTED=false
    }

    STARTED=$(date +%s%3N)
}

status_line() {
    local mark_ui=
    local color=
    local icon=
    local volume=
    local mpg321_pid=

    mpg321_pid=$(pgrep mpg321)
    export NOW_PLAYING=$(readlink -f /proc/"${mpg321_pid}"/fd/3 | awk -F "/" '{print $NF}')

    [[ "${NOW_PLAYING}" == *pipe:[* ]] && {
        kill_music
        NOW_PLAYING=""
        fatal "readlink has failed"
    }

    if [[ "${IS_PAUSED}" == true ]]; then
        icon="${ICON_PAUSED}"
        color="${COLOR_PAUSED}"
    else
        icon="${ICON_PLAYING}"
        color="${COLOR_PLAYING}"
    fi

    if [[ "${IS_MUTED}" == true ]]; then
        volume="${ICON_MUTED}"
        color="${COLOR_MUTED}"
    else
        volume="$(amixer -D pulse get Master | awk '/Left:/' | awk -F '[\[\]]' '{print $2" "}' || "$(error "volume pipe has failed")")"
    fi

    if [ -n "${mpg321_pid}" ]; then
        icon="${icon}"
        color="${color}"
    else
        icon="${ICON_STOPPED}"
        color="${COLOR_STOPPED}"
    fi

    mark_ui="[${#marked_files[@]}]"
    format_status_line="${icon} ${volume}${marked_files[*]:+${mark_ui}} ${NOW_PLAYING}"

    # '\e7':       Save cursor position.
    #              This is more widely supported than '\e[s'.
    # '\e[%sH':    Move cursor to bottom of the terminal.
    # '\e[30;41m': Set foreground and background colors.
    # '%*s':       Insert enough spaces to fill the screen width.
    #              This sets the background color to the whole line
    #              and fixes issues in 'screen' where '\e[K' doesn't work.
    # '\r':        Move cursor back to column 0 (was at EOL due to above).
    # '\e[m':      Reset text formatting.
    # '\e[H\e[K':  Clear line below status_line.
    # '\e8':       Restore cursor position.
    #              This is more widely supported than '\e[u'.
    printf '\e7\e[?6l\e[%sH\e[30;%sm %s\e[K\e[m\n\e[K\e[?6h\e8' \
           "$((LINES-1))" \
           "${color}" \
           "${format_status_line:-/}"
}

read_dir() {
    local dirs=()
    local files=()
    local item_index

    for item in "${PWD}"/*; do
        if [[ -d ${item} ]]; then
            dirs+=("${item}")
            ((item_index++))

            [[ ${item} == "${OLDPWD}" ]] &&
                ((previous_index=item_index))
        else
            files+=("${item}")
        fi
    done

    list=("${dirs[@]}" "${files[@]}")

    [[ -z ${list[0]} ]] &&
        list[0]="empty"

    ((list_total=${#list[@]}-1))

    # Save the original dir in a second list as a backup
    cur_list=("${list[@]}")
}

format_line() {
    local file_name=
    local format
    local suffix

    file_name="${list[$1]##*/}"

    # If the dir is empty, return
    if [[ -z ${list[$1]} ]]; then
        return

    elif [[ -d ${list[$1]} ]]; then
        format+="\\e[${fi:-${COLOR_DIR_BOLD};${COLOR_DIR}}m"
        suffix+='/'

    elif [[ ${list[$1]} == *${NOW_PLAYING} ]] && [[ ${NOW_PLAYING} == *".mp3" ]]; then
        format+="\\e[${fi:-${COLOR_CURRENT_SONG_BOLD};${COLOR_CURRENT_SONG}m}"
        suffix+='♫ '

    else
        format+="\\e[${fi:-${COLOR_OTHER_BOLD};${COLOR_OTHER}}m"
    fi

    # If the item is under the cursor
    (($1 == scroll)) &&
        format+="\\e[1;${COLOR_CURSOR};7m"

    # If the item is marked
    [[ ${marked_files[$1]} == "${list[$1]:-null}" ]] && {
        format+="\\e[${COLOR_MARKED_BOLD};${COLOR_MARKED}m${ICON_MARKED} "
    }

    # Escape the directory string
    file_name="${file_name//[^[:print:]]/^[}"

    printf '\r%b%s\e[m\r' "${format}" "${file_name}${suffix}"
}

draw_dir() {
    # Print the max directory items that fit in the scroll area
    local scroll_start=
    local scroll_new_pos=
    local scroll_end=

    scroll_start="${scroll}"

    # When going up the directory tree, place the cursor on the position
    # of the previous directory
    ((find_previous == 1)) && {
        ((scroll_start=previous_index-1))
        ((scroll=scroll_start))

        find_previous=
    }

    # If current dir is near the top of the list, keep scroll position
    if ((list_total < max_items || scroll < max_items/2)); then
        ((scroll_start=0))
        ((scroll_end=max_items))
        ((scroll_new_pos=scroll + 1))

    # If curent dir is near the end of the list, keep scroll position
    elif ((list_total - scroll < max_items/2)); then
        ((scroll_start=list_total - max_items + 1))
        ((scroll_new_pos=max_items - (list_total-scroll)))
        ((scroll_end=list_total+1))

    # If current dir is somewhere in the middle, center scroll position
    else
        ((scroll_start=scroll-max_items/2))
        ((scroll_end=scroll_start+max_items))
        ((scroll_new_pos=max_items/2+1))
    fi

    # Reset cursor position
    printf '\e[H'

    for ((i=scroll_start;i<scroll_end;i++)); {
        # Don't print one too many newlines
        ((i > scroll_start)) &&
            printf '\n'

        format_line "${i}"
    }

    # Move the cursor to its new position if it changed
    printf '\e[%sH' "${scroll_new_pos}"
    ((y=scroll_new_pos))
}

redraw() {
    [[ $1 == full ]] && {
        read_dir || error "read_dir has failed"
        scroll=0
    }

    clear_screen
    draw_dir
    status_line
}

mark() {
    [[ ${list[0]} == empty && -z ${list[1]} ]] &&
        return

    if [[ $1 == all ]]; then
        if ((${#marked_files[@]} != ${#list[@]})); then
            marked_files=("${list[@]}")
            export mark_dir="$PWD"
        else
            marked_files=()
        fi

        redraw
    else
        if [[ ${marked_files[$1]} == "${list[$1]}" ]]; then
            unset 'marked_files[scroll]'

        else
            marked_files[$1]="${list[$1]}"
            export mark_dir="${PWD}"
        fi

        # Clear line before changing it
        printf '\e[K'
        format_line "${1}"
    fi

    status_line
}

open() {
    if [[ -d ${1}/ ]]; then
        search=
        search_end_early=
        export previous_dir="${PWD}"
        cd "${1:-/}" ||:
        redraw full

    elif [[ -f ${1} ]]; then
        # Figure out file type
        nohup "${FILE_OPENER:-${opener:-xdg-open}}" "$1" &>/dev/null &
        disown
    fi
}

cmd_line() {
    cmd_reply=

    printf '\e7\e[%sH\e[?25h' "${LINES}"

    while IFS= read -rsn 1 -p $'\r\e[K'"${1}${cmd_reply}" read_reply; do
        case "${read_reply}" in
            # Backspace
            $'\177'|$'\b')
                cmd_reply="${cmd_reply%?}"

                # Clear tab-completion
                unset comp c
            ;;

            # Tab
            $'\t')
                comp_glob="${cmd_reply}*"

                # Pass the argument dirs to limit completion to directories
                [[ ${2} == dirs ]] &&
                    comp_glob="${cmd_reply*/}"

                # Generate a completion list once
                [[ -z ${comp[0]} ]] &&
                    IFS=$'\n' read -d "" -ra comp < <(compgen -G "${comp_glob}")

                # On each tab press, cycle through the completion list
                [[ -n ${comp[c]} ]] && {
                    cmd_reply="${comp[c]}"
                    ((c=c >= ${#comp[@]}-1 ? 0 : ++c))
                }
            ;;

            # Escape / Custom 'no' value (used as a replacement for '-n 1')
            $'\e'|"${3:-null}")
                cmd_reply=
                break
            ;;

            # Enter/Return
            "")
                # If there's only one search result and its a directory,
                # enter it on one enter keypress
                [[ $2 == search && -d ${list[0]} ]] && ((list_total == 0)) && {
                    # '\e[?25l': Hide the cursor
                    printf '\e[?25l'

                    open "${list[0]}"
                    search_end_early=1

                    # Unset tab completion variables since we're done
                    unset comp c
                    return
                }

                break
            ;;

            # Custom 'yes' value (used as a replacement for '-n 1')
            "${2:-null}")
                cmd_reply="${read_reply}"
                break
            ;;

            # Anything else, add it to read reply
            " "|*)
                cmd_reply+="${read_reply}"

                # Clear tab-completion
                unset comp c
            ;;
        esac

        # Search on keypress if search passed as an argument
        [[ ${2} == search ]] && {
            # '\e[?25l': Hide the cursor
            printf '\e[?25l'

            # Use a greedy glob to search
            list=("${PWD}"/*"${cmd_reply}"*)
            ((list_total=${#list[@]}-1))

            # Draw the search results on screen
            scroll=0
            redraw

            # '\e[%sH':  Move cursor back to cmd-line
            # '\e[?25h': Unhide the cursor
            printf '\e[%sH\e[?25h' "${LINES}"
        }
    done

    # Unset tab completion
    unset comp c

    # '\e[2K':   Clear the entire cmd_line on finish.
    # '\e[?25l': Hide the cursor.
    # '\e8':     Restore cursor position.
    printf '\e[2K\e[?25l\e8'
}

kill_music () {
    local mpg321_pid=

    mpg321_pid="$(pgrep mpg321)"

    # Do nothing if mpg321 is not running
    if [ -z "${mpg321_pid}" ]; then
        return

    # If mpg321 is suspended, resume & send 2 SIGINTs to kill it
    elif [[ $(awk 'NR==3{print $2}' "/proc/${mpg321_pid}/status") == "T" ]]; then
        (kill -CONT "${mpg321_pid}";\
            2>/dev/null 1>&2 killall -s SIGINT mpg321;\
            2>/dev/null 1>&2 killall -s SIGINT mpg321)

    elif [ -n "${mpg321_pid}" ]; then
        (2>/dev/null 1>&2 killall -s SIGINT mpg321;\
            2>/dev/null 1>&2 killall -s SIGINT mpg321)
    fi
}

reload () {
    # Redraw screen twice, first time updates status_line,
    # second time updates COLOR_CURRENT_SONG
    sleep 0.2
    clear_screen
    redraw
    redraw
}

next_song () {
    local min_age=
    local keypress=
    local age=
    local mpg321_pid=

    mpg321_pid=$(pgrep mpg321)
    min_age=1050 # milliseconds
    keypress=$(date +%s%3N)

    age="((${keypress}-${STARTED}))"

    # Don't allow the user to skip to the next song within the first second,
    # otherwise mpg321 is killed
    [[ -n "${mpg321_pid}" ]] && {
        if [[ "${age}" -ge "${min_age}" ]]; then

            if [[ $(awk 'NR==3{print $2}' "/proc/${mpg321_pid}/status") == "T" ]]; then
                (kill -CONT "${mpg321_pid}")
                IS_PAUSED=false
            fi

            # A single SIGINT (ctrl-c) to mpg321 goes to the next song
            (2>/dev/null 1>&2 killall -s SIGINT mpg321)
            STARTED=$(date +%s%3N)

            reload
        else
            return
        fi
    }||:
}

pause_or_play () {
    local mpg321_pid=
    local mpg321_status=

    mpg321_pid=$(pgrep mpg321)

    # If mpg321 is not running, play
    if [ -z "${mpg321_pid}" ]; then
        # If list item is a dir, play all in dir
        if [[ -d ${list[scroll]} ]]; then
            (2>/dev/null 1>&2 mpg321 "${list[scroll]}" -B --shuffle &)
            IS_PAUSED=false
            STARTED=$(date +%s%3N)
            reload; return

        else
            (2>/dev/null 1>&2 mpg321 "${list[scroll]}" &)
            IS_PAUSED=false
            STARTED=$(date +%s%3N)
            reload; return
        fi
    fi

    mpg321_status=$(awk 'NR==3{print $2}' "/proc/${mpg321_pid}/status")

    # Elif process is running; stop
    if [[ ${mpg321_status} == "S" ]]; then
        (kill -STOP "${mpg321_pid}")
        IS_PAUSED=true
        reload; return

    # Elif stopped; resume
    elif [[ ${mpg321_status} == "T" ]]; then
        (kill -CONT "${mpg321_pid}")
        IS_PAUSED=false
        STARTED=$(date +%s%3N)
        reload; return
    fi
}

play_all_in_dir () {
    kill_music

    [[ -d ${list[scroll]} ]] && {
        (2>/dev/null 1>&2 mpg321 "${list[scroll]}" -B &)
    }|| (2>/dev/null 1>&2 mpg321 ./*.mp3 &)

    IS_PAUSED=false
    STARTED=$(date +%s%3N)

    reload
}

shuffle_all_in_dir () {
    kill_music

    [[ -d ${list[scroll]} ]] && {
        (2>/dev/null 1>&2 mpg321 "${list[scroll]}" -B --shuffle &)
    }|| (2>/dev/null 1>&2 mpg321 ./*.mp3 --shuffle &)

    IS_PAUSED=false
    STARTED=$(date +%s%3N)

    reload
}

mark_song_for_playlist () {
    # Don't mark dirs
    [[ -d ${list[scroll]} ]] &&
        :|| mark "${scroll}" #"${1}"

    # Scroll down one item
    ((scroll < list_total)) && {
        ((scroll++))
        ((y < max_items )) && ((y++))

        format_line "$((scroll-1))"
        printf '\n'
        format_line "${scroll}"
        status_line
    }
}

play_marked_songs () {
    if ((${#marked_files[@]} != 0)); then
        playlist_file="${XDG_CACHE_HOME}/shellaro/playlist"
        # Save marked files to a file and open them for editing
        printf '%s\n' "${marked_files[@]}" > "${playlist_file}"

        kill_music
        (2>/dev/null 1>&2 mpg321 --list "${playlist_file}" &)

        marked_files=()
        IS_PAUSED=false
        STARTED=$(date +%s%3N)
        reload; return

    elif [[ ${list[scroll]} == *.mp3 ]]; then
        kill_music
        (2>/dev/null 1>&2 mpg321 "${list[scroll]}" &)
        IS_PAUSED=false
        STARTED=$(date +%s%3N)
        reload; return

    elif [[ ${list[scroll]} == *.list ]]; then
        kill_music
        (2>/dev/null 1>&2 mpg321 --list "${list[scroll]}" --shuffle &)
        IS_PAUSED=false
        STARTED=$(date +%s%3N)
        reload; return

    elif [[ -d ${list[scroll]} ]]; then
        open "${list[scroll]}"
    fi
}

# TODO better playlists, this is just a quick solution to get it working
add_marked_to_playlist () {
    local custom_playlist=

    if ((${#marked_files[@]} != 0)); then
        cmd_line "add to: "
        custom_playlist="${MUSIC_DIRECTORY}/.playlists/${cmd_reply}.list"
        # Save marked files to a file and open them for editing
        printf '%s\n' "${marked_files[@]}" >> "${custom_playlist}"

        marked_files=()
        redraw
    fi
}

delete_playlist () {
    local custom_playlist=

    cmd_line "delete playlist: "

    custom_playlist="${MUSIC_DIRECTORY}/.playlists/${cmd_reply}.list"

    if [[ -f "${custom_playlist}" ]] && [[ "${PWD}" == "${MUSIC_DIRECTORY}"/.playlists ]]; then
        rm "${custom_playlist}"
        redraw full; return
    elif [[ -f "${custom_playlist}" ]]; then
        rm "${custom_playlist}"
    fi

    redraw
}

find_current_song () {
    local mpg321_pid=

    mpg321_pid=$(pgrep mpg321)

    # If mpg231 is not running, don't search
    [[ -z "${mpg321_pid}" ]] &&
        return

    open "$(locate "$(readlink -f /proc/"${mpg321_pid}"/fd/3  \
        | awk -F "/" '{print $NF}')" \
        | awk -F "/" '{$NF=""; print $0}' \
        | sed s/' '/'\/'/g)" || exit 1

    reload
}

find_and_play () {
    local search_result=

    cmd_line "locate: "

    if [[ -n "${cmd_reply}" ]]; then
        search_result="$(locate -iqt "${cmd_reply}" | sed q)"

        if [[ "${search_result}" = "$MUSIC_DIRECTORY/"* ]]; then
            if [[ -d ${search_result} ]];then
                kill_music
                (2>/dev/null 1>&2 mpg321 "${search_result}" -B --shuffle &)

                IS_PAUSED=false
                STARTED=$(date +%s%3N)
                reload; return

            elif [[ "${search_result}" = "${MUSIC_DIRECTORY}/"*.mp3 ]]; then
                kill_music
                (2>/dev/null 1>&2 mpg321 "${search_result}" &)

                IS_PAUSED=false
                STARTED=$(date +%s%3N)
                reload; return

            elif [[ "${search_result}" = "${MUSIC_DIRECTORY}/"*.list ]]; then
                playlist_file="${search_result}"

                kill_music
                (2>/dev/null 1>&2 mpg321 --list "${playlist_file}" --shuffle &)

                IS_PAUSED=false
                STARTED=$(date +%s%3N)
                reload; return

            else
                search_result="$(locate -qt "${cmd_reply}" | sed q)"

                if [[ "${search_result}" = "${MUSIC_DIRECTORY}/"* ]]; then
                    if [[ -d ${search_result} ]]; then
                        kill_music
                        (2>/dev/null 1>&2 mpg321 "${search_result}" -B --shuffle &)

                        IS_PAUSED=false
                        STARTED=$(date +%s%3N)
                        reload; return

                    elif [[ "${search_result}" = "${MUSIC_DIRECTORY}/"*.mp3 ]]; then
                        kill_music
                        (2>/dev/null 1>&2 mpg321 "${search_result}" &)

                        IS_PAUSED=false
                        STARTED=$(date +%s%3N)
                        reload; return

                    elif [[ "${search_result}" = "${MUSIC_DIRECTORY}/"*.list ]]; then
                        playlist_file="${search_result}"

                        kill_music
                        (2>/dev/null 1>&2 mpg321 --list "${playlist_file}" --shuffle &)

                        IS_PAUSED=false
                        STARTED=$(date +%s%3N)
                        reload; return
                    fi
                fi
            fi
        fi
    fi
}

search_in_dir () {
    cmd_line "/" "search"

    # If the search came up empty, redraw the current dir
    if [[ -z ${list[*]} || -z ${cmd_reply} ]]; then
        list=("${cur_list[@]}")
        ((list_total=${#list[@]}-1))
        redraw
        search=
    else
        search=1
    fi
}

shuffle_all () {
    kill_music
    (2>/dev/null 1>&2 mpg321 "${MUSIC_DIRECTORY}" -B --shuffle &)

    IS_PAUSED=false
    STARTED=$(date +%s%3N)

    reload
}

mute_or_unmute () {
    (2>/dev/null 1>&2 amixer -D pulse sset Master toggle)
    [ -n "$(amixer -D pulse get Master | awk '/\[off\]/')" ] &&
        IS_MUTED=true || IS_MUTED=false

    redraw
}

set_volume () {
    cmd_line "volume: "
    # if cmd_reply is between 0 & 100
    [ "${cmd_reply}" -ge 0 ] && [ "${cmd_reply}" -le 100 ] &&
        (2>/dev/null 1>&2 amixer -D pulse sset Master "${cmd_reply}"%)

    redraw
}

execute_command () {
    cmd_line ":"

    # Quit
    if [[ "${cmd_reply}" == "q" ]]; then
        exit
    fi

    if [[ "${cmd_reply}" == "add" ]]; then
        add_marked_to_playlist
    fi

    if [[ "${cmd_reply}" == "del" ]]; then
        delete_playlist
    fi

    if [[ "${cmd_reply}" == "list" ]]; then
        open "${MUSIC_DIRECTORY}"/.playlists
    fi

    if [[ "${cmd_reply}" == "debug" ]]; then
        set -x
        DEBUG=true
        redraw full
    fi

    if [[ "${cmd_reply}" == "debug-x" ]]; then
        strace -qqfe execve ~/GitHub/shellaro/shellaro "${0}" && exit
        DEBUG=true
        redraw full
    fi
}

go_to_child () {
    if [[ ${list[scroll]} == *.mp3 ]]; then
        kill_music
        (2>/dev/null 1>&2 mpg321 "${list[scroll]}" &)

        IS_PAUSED=false
        STARTED=$(date +%s%3N)

        reload

    elif [[ ${list[scroll]} == *.list ]]; then
        kill_music
        (2>/dev/null 1>&2 mpg321 --list "${list[scroll]}" --shuffle &)

        IS_PAUSED=false
        STARTED=$(date +%s%3N)

        reload

    elif [[ -d ${list[scroll]} ]]; then
        open "${list[scroll]}"
    fi

    redraw
}

go_to_parent () {
    # If a search was done, clear the results and open the current dir
    if ((search == 1 && search_end_early != 1)); then
        open "${PWD}"

    # If '$PWD' is not $MUSIC_DIRECTORY or a subdirectory
    # of, don't go to parent
    elif [[ "${PWD}" = *"${MUSIC_DIRECTORY}/"* ]]; then
        find_previous=1
        open "${PWD%/*}"
    fi
}

scroll_down () {
    ((scroll < list_total)) && {
        ((scroll++))
        ((y < max_items )) && ((y++))

        format_line "$((scroll-1))"
        printf '\n'
        format_line "${scroll}"
        #status_line
    }
}

scroll_up () {
    ((scroll > 0)) && {
        ((scroll--))

        format_line "$((scroll+1))"

        if ((y < 2)); then
            printf '\e[1L'
        else
            printf '\e[A'
            ((y--))
        fi

        format_line "${scroll}"
        #status_line
    }
}

toggle_hidden_files () {
    # 'a=a>0?0:++a': Toggle between both values of 'shopt_flags'.
    #                This also works for '3' or more values with
    #                some modification.
    shopt_flags=(u s)
    shopt -"${shopt_flags[((a=a>0?0:++a))]}" dotglob
    redraw full
}

key() {
    case "${1}" in

        :) execute_command ;;

        l|C|$'\eOC'|$'\e[C') go_to_child ;;

        h|D|$'\eOD'|$'\e[D'|$'\b'|$'\177') go_to_parent ;;

        j|B|$'\eOB'|$'\e[B') scroll_down ;;

        k|A|$'\eOA'|$'\e[A') scroll_up ;;

        # Jump to top
        g) ((scroll != 0)) && ((scroll=0)); redraw ;;

        # Jump to bottom
        G) ((scroll != list_total)) && ((scroll=list_total)); redraw ;;

        /) search_in_dir ;;

        \;) find_and_play ;;

        .) toggle_hidden_files ;;

        f) find_current_song ;;

        " ") mark_song_for_playlist ;;

        # "" ENTER key
        "") play_marked_songs ;;

        # " " SPACE key, clear selection
        x|c) marked_files=(); redraw;;

        p) pause_or_play ;;

        n) next_song ;;

        \`) open "${MUSIC_DIRECTORY}"/.playlists ;;

        ~|0) open "${MUSIC_DIRECTORY}" ;;

        a) play_all_in_dir ;;

        s) shuffle_all_in_dir ;;

        S) shuffle_all ;;

        # Volume Up
        u|+) (2>/dev/null 1>&2 amixer -D pulse sset Master "${INCREMENT_VOLUME}"%+ unmute); redraw ;;

        # Volume Down
        d|-) (2>/dev/null 1>&2 amixer -D pulse sset Master "${INCREMENT_VOLUME}"%-); redraw ;;

        v|=) set_volume ;;

        m) mute_or_unmute ;;

        # Jump To Favs
        [1-9]) favorite="SHORTCUT_${1}"; favorite="${!favorite}"; open "${favorite}" ;;

        # Kill mpg321
        K) kill_music; reload ;;

        # Redraw, useful when bugs appear!
        r) clear_screen; redraw full; reload ;;

        # Create a new instance of the program
        # and exit the current instance (for testing)
        R)
            kill -SIGTERM "$(awk 'NR==1{print}' "${XDG_CACHE_HOME}"/shellaro/daemon_pid)"
            ~/GitHub/shellaro/shellaro "${0}" && exit
        ;;

        q|Q) exit ;;
    esac
}

get_args() {
    while [[ "${1}" ]]; do
        case "${1}" in
            "-v"|"--version")
                printf '%s\n' "shellaro ${VERSION}"
                exit
            ;;

            "-d"|"--debug")
                [[ "${2}" ]] && {
                    case "${2}" in
                        "x")
                            strace -qqfe execve ~/GitHub/shellaro/shellaro "${0}" && exit
                        ;;
                    esac
                }

                set -x
                DEBUG=true
            ;;

        esac
        shift
    done
}

shellaro_daemon() {
    # Infinite loop
    for ((;;)); {
        local mpg321_pid=

        mpg321_pid=$(pgrep mpg321)

        export STATUS_DAEMON=$(readlink -f /proc/"${mpg321_pid}"/fd/3 | awk -F "/" '{print $NF}')

        [[ "${STATUS_DAEMON}" == *pipe:[* ]] && {
            kill_music
            export STATUS_DAEMON=""
            fatal "readlink has failed"
        }

        [[ -t 1 ]] || exit 1

        sleep 0.2
    }
}

main() {
    # Don't record function calls in command history
    set -o nolog

    set -o pipefail

    # Locate & remember commands invoked by functions as functions are defined.
    set -h

    get_args "${@}"
    set_initial_status || error "initial status check failed"

    set -e

    # Do nothing if cd fails
    cd "${2:-$1}" &>/dev/null ||:

    # bash 5 and some versions of bash 4 don't allow SIGWINCH to interrupt
    # a 'read' command and instead wait for it to complete. In this case it
    # causes the window to not redraw on resize until the user has pressed
    # a key (causing the read to finish). This sets a read timeout on the
    # affected versions of bash
    ((BASH_VERSINFO[0] > 3)) &&
        read_flags=(-t 0.60)

    # 'nocaseglob': Glob case insensitively (Used for case insensitive search)
    # 'nullglob':   Don't expand non-matching globs to themselves
    shopt -s nocaseglob nullglob

    # Trap the exit signal (we need to reset the terminal to a useable state.)
    trap 'cleanup' EXIT

    # Trap terminate signal for a clean kill.
    trap 'cleanup' SIGTERM

    # Trap the window resize signal (handle window resize events)
    trap 'get_term_size; redraw' WINCH

    [[ ! -d "${MUSIC_DIRECTORY}/.playlists" ]] && {
        mkdir -p "${MUSIC_DIRECTORY}/.playlists"
    }

    [[ ! -d "${XDG_CACHE_HOME}/shellaro" ]] && {
        mkdir -p "${XDG_CACHE_HOME}/shellaro"
    }

    [[ ! -f "${XDG_CACHE_HOME}/shellaro/playlist" ]] && {
        touch "${XDG_CACHE_HOME}/shellaro/playlist"
    }

    [[ ! -f "${XDG_CACHE_HOME}/shellaro/error_log" ]] && {
        touch "${XDG_CACHE_HOME}/shellaro/error_log"
    }

    [[ ! -f "${XDG_CACHE_HOME}/shellaro/daemon_pid" ]] && {
        touch "${XDG_CACHE_HOME}/shellaro/daemon_pid"
    }

    get_term_size
    setup_tui

    set +e

    open "${MUSIC_DIRECTORY}" || fatal "could not open MUSIC_DIRECTORY"
    redraw full

    # Run and cache PID for cleanup
    (shellaro_daemon & echo $! > "${XDG_CACHE_HOME}"/shellaro/daemon_pid)

    # Infinite loop
    for ((;;)); {
        read "${read_flags[@]}" -srn 1 && key "${REPLY}"

        # reload the screen if music changes
        [[ "${NOW_PLAYING}" != "${STATUS_DAEMON}" ]] && redraw

        # Exit if there is no longer a terminal attached
        [[ -t 1 ]] || exit 1
    }
}

main "${@}"
